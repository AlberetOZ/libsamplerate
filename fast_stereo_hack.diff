=== modified file 'src/src_sinc.c'
--- src/src_sinc.c	2008-09-26 22:27:23 +0000
+++ src/src_sinc.c	2008-12-10 22:54:21 +0000
@@ -65,11 +65,14 @@
 	coeff_t const	*coeffs ;
 
 	int		b_current, b_end, b_real_end, b_len ;
-	float	buffer [1] ;
+
+	/* C99 struct flexible array. */
+	float	buffer [] ;
 } SINC_FILTER ;
 
 static int sinc_multichan_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
-static int sinc_1chan_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static int sinc_stereo_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static int sinc_mono_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
 
 static void prepare_data (SINC_FILTER *filter, SRC_DATA *data, int half_filter_chan_len) ;
 
@@ -167,8 +170,13 @@
 	temp_filter.channels = psrc->channels ;
 
 	if (psrc->channels == 1)
-	{	psrc->const_process = sinc_1chan_vari_process ;
-		psrc->vari_process = sinc_1chan_vari_process ;
+	{	psrc->const_process = sinc_mono_vari_process ;
+		psrc->vari_process = sinc_mono_vari_process ;
+		}
+	else
+	if (psrc->channels == 2)
+	{	psrc->const_process = sinc_stereo_vari_process ;
+		psrc->vari_process = sinc_stereo_vari_process ;
 		}
 	else
 	{	psrc->const_process = sinc_multichan_vari_process ;
@@ -303,6 +311,246 @@
 	return (left + right) ;
 } /* calc_output_single */
 
+static int
+sinc_mono_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc->private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc->private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter->buffer [0]) != sizeof (data->data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter->in_count = data->input_frames * filter->channels ;
+	filter->out_count = data->output_frames * filter->channels ;
+	filter->in_used = filter->out_gen = 0 ;
+
+	src_ratio = psrc->last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter->coeff_half_len + 2.0) / filter->index_inc ;
+	if (MIN (psrc->last_ratio, data->src_ratio) < 1.0)
+		count /= MIN (psrc->last_ratio, data->src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter->channels * (lrint (count) + 1) ;
+
+	input_index = psrc->last_position ;
+	float_increment = filter->index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter->out_gen < filter->out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+
+		if (samples_in_hand <= half_filter_chan_len)
+		{	prepare_data (filter, data, half_filter_chan_len) ;
+
+			samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+			if (samples_in_hand <= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter->b_real_end >= 0)
+		{	if (filter->b_current + input_index + terminate >= filter->b_real_end)
+				break ;
+			} ;
+
+		if (filter->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > 1e-10)
+			src_ratio = psrc->last_ratio + filter->out_gen * (data->src_ratio - psrc->last_ratio) / filter->out_count ;
+
+		float_increment = filter->index_inc * 1.0 ;
+		if (src_ratio < 1.0)
+			float_increment = filter->index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		data->data_out [filter->out_gen] = (float) ((float_increment / filter->index_inc) *
+										calc_output_single (filter, increment, start_filter_index)) ;
+		filter->out_gen ++ ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc->last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc->last_ratio = src_ratio ;
+
+	data->input_frames_used = filter->in_used / filter->channels ;
+	data->output_frames_gen = filter->out_gen / filter->channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_mono_vari_process */
+
+static inline void
+calc_output_stereo (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, double scale, float * output)
+{	double		fraction, left [2], right [2], icoeff ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter->coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current - filter->channels * coeff_count ;
+
+	left [0] = left [1] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		left [0] += icoeff * filter->buffer [data_index] ;
+		left [1] += icoeff * filter->buffer [data_index + 1] ;
+
+		filter_index -= increment ;
+		data_index = data_index + 2 ;
+		}
+	while (filter_index >= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current + filter->channels * (1 + coeff_count) ;
+
+	right [0] = right [1] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		right [0] += icoeff * filter->buffer [data_index] ;
+		right [1] += icoeff * filter->buffer [data_index + 1] ;
+
+		filter_index -= increment ;
+		data_index = data_index - filter->channels ;
+		}
+	while (filter_index > MAKE_INCREMENT_T (0)) ;
+
+	output [0] = scale * (left [0] + right [0]) ;
+	output [1] = scale * (left [1] + right [1]) ;
+} /* calc_output_stereo */
+
+static int
+sinc_stereo_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc->private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc->private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter->buffer [0]) != sizeof (data->data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter->in_count = data->input_frames * filter->channels ;
+	filter->out_count = data->output_frames * filter->channels ;
+	filter->in_used = filter->out_gen = 0 ;
+
+	src_ratio = psrc->last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter->coeff_half_len + 2.0) / filter->index_inc ;
+	if (MIN (psrc->last_ratio, data->src_ratio) < 1.0)
+		count /= MIN (psrc->last_ratio, data->src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter->channels * (lrint (count) + 1) ;
+
+	input_index = psrc->last_position ;
+	float_increment = filter->index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter->out_gen < filter->out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+
+		if (samples_in_hand <= half_filter_chan_len)
+		{	prepare_data (filter, data, half_filter_chan_len) ;
+
+			samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+			if (samples_in_hand <= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter->b_real_end >= 0)
+		{	if (filter->b_current + input_index + terminate >= filter->b_real_end)
+				break ;
+			} ;
+
+		if (filter->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > 1e-10)
+			src_ratio = psrc->last_ratio + filter->out_gen * (data->src_ratio - psrc->last_ratio) / filter->out_count ;
+
+		float_increment = filter->index_inc * 1.0 ;
+		if (src_ratio < 1.0)
+			float_increment = filter->index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		calc_output_stereo (filter, increment, start_filter_index, float_increment / filter->index_inc, data->data_out + filter->out_gen) ;
+		filter->out_gen += 2 ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc->last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc->last_ratio = src_ratio ;
+
+	data->input_frames_used = filter->in_used / filter->channels ;
+	data->output_frames_gen = filter->out_gen / filter->channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_stereo_vari_process */
+
 static inline double
 calc_output_multi (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, int ch)
 {	double		fraction, left, right, icoeff ;
@@ -356,99 +604,6 @@
 } /* calc_output_multi */
 
 static int
-sinc_1chan_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
-{	SINC_FILTER *filter ;
-	double		input_index, src_ratio, count, float_increment, terminate, rem ;
-	increment_t	increment, start_filter_index ;
-	int			half_filter_chan_len, samples_in_hand ;
-
-	if (psrc->private_data == NULL)
-		return SRC_ERR_NO_PRIVATE ;
-
-	filter = (SINC_FILTER*) psrc->private_data ;
-
-	/* If there is not a problem, this will be optimised out. */
-	if (sizeof (filter->buffer [0]) != sizeof (data->data_in [0]))
-		return SRC_ERR_SIZE_INCOMPATIBILITY ;
-
-	filter->in_count = data->input_frames * filter->channels ;
-	filter->out_count = data->output_frames * filter->channels ;
-	filter->in_used = filter->out_gen = 0 ;
-
-	src_ratio = psrc->last_ratio ;
-
-	/* Check the sample rate ratio wrt the buffer len. */
-	count = (filter->coeff_half_len + 2.0) / filter->index_inc ;
-	if (MIN (psrc->last_ratio, data->src_ratio) < 1.0)
-		count /= MIN (psrc->last_ratio, data->src_ratio) ;
-
-	/* Maximum coefficientson either side of center point. */
-	half_filter_chan_len = filter->channels * (lrint (count) + 1) ;
-
-	input_index = psrc->last_position ;
-	float_increment = filter->index_inc ;
-
-	rem = fmod_one (input_index) ;
-	filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
-	input_index = rem ;
-
-	terminate = 1.0 / src_ratio + 1e-20 ;
-
-	/* Main processing loop. */
-	while (filter->out_gen < filter->out_count)
-	{
-		/* Need to reload buffer? */
-		samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
-
-		if (samples_in_hand <= half_filter_chan_len)
-		{	prepare_data (filter, data, half_filter_chan_len) ;
-
-			samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
-			if (samples_in_hand <= half_filter_chan_len)
-				break ;
-			} ;
-
-		/* This is the termination condition. */
-		if (filter->b_real_end >= 0)
-		{	if (filter->b_current + input_index + terminate >= filter->b_real_end)
-				break ;
-			} ;
-
-		if (filter->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > 1e-10)
-			src_ratio = psrc->last_ratio + filter->out_gen * (data->src_ratio - psrc->last_ratio) / filter->out_count ;
-
-		float_increment = filter->index_inc * 1.0 ;
-		if (src_ratio < 1.0)
-			float_increment = filter->index_inc * src_ratio ;
-
-		increment = double_to_fp (float_increment) ;
-
-		start_filter_index = double_to_fp (input_index * float_increment) ;
-
-		data->data_out [filter->out_gen] = (float) ((float_increment / filter->index_inc) *
-										calc_output_single (filter, increment, start_filter_index)) ;
-		filter->out_gen ++ ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		rem = fmod_one (input_index) ;
-
-		filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
-		input_index = rem ;
-		} ;
-
-	psrc->last_position = input_index ;
-
-	/* Save current ratio rather then target ratio. */
-	psrc->last_ratio = src_ratio ;
-
-	data->input_frames_used = filter->in_used / filter->channels ;
-	data->output_frames_gen = filter->out_gen / filter->channels ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* sinc_1chan_vari_process */
-
-static int
 sinc_multichan_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
 {	SINC_FILTER *filter ;
 	double		input_index, src_ratio, count, float_increment, terminate, rem ;

